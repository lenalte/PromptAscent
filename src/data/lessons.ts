
'use server';

import fs from 'fs/promises';
import path from 'path';
import { generateLessonItems } from '@/ai/flows/generate-lesson-items-flow';
import type { Lesson, LessonItem, LessonStage } from '@/ai/schemas/lesson-schemas'; // Import types from Zod schemas

// Re-export types for use in components
export type { Lesson, LessonItem, LessonStage, FreeResponseLessonItem, MultipleChoiceLessonItem, InformationalSnippetLessonItem, PromptingTaskLessonItem } from '@/ai/schemas/lesson-schemas';
export type { StageItemStatus, StageProgress, StageStatusValue, BossQuestion } from '@/ai/schemas/lesson-schemas';


const LESSON_CONTENT_DIR = path.join(process.cwd(), 'src', 'data', 'lesson-content');
const LESSON_MANIFEST_PATH = path.join(process.cwd(), 'src', 'data', 'lessons-manifest.json');

interface LessonManifestEntry {
  id: string;
  title: string;
  description: string;
  contentFileName: string;
}

async function getLessonManifest(): Promise<LessonManifestEntry[]> {
  console.log('[SERVER LOG] [getLessonManifest] Attempting to read lesson manifest.');
  console.log(`[SERVER LOG] [getLessonManifest] Reading from path: ${LESSON_MANIFEST_PATH}`);
  try {
    const manifestContent = await fs.readFile(LESSON_MANIFEST_PATH, 'utf-8');
    const manifest = JSON.parse(manifestContent) as LessonManifestEntry[];
    console.log(`[SERVER LOG] [getLessonManifest] Successfully parsed lesson manifest. Number of entries: ${manifest.length}`);
    if (manifest.length === 0) {
        console.warn("[SERVER LOG] [getLessonManifest] WARNING: Parsed manifest is empty.");
    }
    return manifest;
  } catch (error) {
    console.error("[SERVER LOG] [getLessonManifest] CRITICAL: Failed to read or parse lesson manifest:", error);
    return [];
  }
}

export async function getAvailableLessons(): Promise<Omit<Lesson, 'stages'>[]> {
  console.log('[SERVER LOG] [getAvailableLessons] Attempting to get available lessons.');
  const manifest = await getLessonManifest();
  console.log(`[SERVER LOG] [getAvailableLessons] Manifest received in getAvailableLessons. Length: ${manifest.length}`);
  if (manifest.length === 0) {
    console.warn("[SERVER LOG] [getAvailableLessons] WARNING: The lesson manifest is empty. This will lead to issues in lesson progression and display.");
  }
  return manifest.map(({ id, title, description }) => ({ id, title, description }));
}

const lessonCache = new Map<string, Lesson>();

export async function getGeneratedLessonById(lessonId: string): Promise<Lesson | undefined> {
  if (process.env.NODE_ENV === 'development' && lessonCache.has(lessonId)) {
    // console.log(`Returning cached lesson: ${lessonId}`);
    return lessonCache.get(lessonId); // Re-enable cache for performance
  }

  const manifest = await getLessonManifest();
  const lessonEntry = manifest.find(l => l.id === lessonId);

  if (!lessonEntry) {
    console.warn(`[SERVER LOG] [getGeneratedLessonById] Lesson with ID "${lessonId}" not found in manifest.`);
    throw new Error(`Lesson with ID "${lessonId}" not found in manifest.`);
  }

  try {
    const filePath = path.join(LESSON_CONTENT_DIR, lessonEntry.contentFileName);
    const rawContent = await fs.readFile(filePath, 'utf-8');

    const MAX_RETRIES = 3;
    const RETRY_DELAY_MS = 2000;
    let generatedLessonData: Lesson | undefined;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`[SERVER LOG] [Lesson: ${lessonId}] Attempt ${attempt}/${MAX_RETRIES} to generate lesson items with stages...`);
        generatedLessonData = await generateLessonItems({
          lessonId: lessonEntry.id,
          lessonTitle: lessonEntry.title,
          lessonDescription: lessonEntry.description,
          rawContent: rawContent,
        });

        if (generatedLessonData && generatedLessonData.stages && generatedLessonData.stages.length === 6) {
          console.log(`[SERVER LOG] [Lesson: ${lessonId}] Successfully generated lesson with 6 stages on attempt ${attempt}.`);
          // Validate unique item IDs across stages
          const allItemIds = new Set<string>();
          let duplicateFound = false;
          generatedLessonData.stages.forEach(stage => {
            (stage.items || []).forEach(item => {
              if(allItemIds.has(item.id)) {
                console.error(`[SERVER LOG] [Lesson: ${lessonId}] CRITICAL: Duplicate item ID "${item.id}" generated by AI across stages. This will cause issues.`);
                duplicateFound = true;
              }
              allItemIds.add(item.id);
            });
          });
          if (duplicateFound) {
            throw new Error(`AI generated duplicate item IDs for lesson "${lessonId}". Please regenerate or check AI prompt.`);
          }
          break;
        } else {
          const stagesCount = generatedLessonData?.stages?.length ?? 'undefined';
          console.warn(`[SERVER LOG] [Lesson: ${lessonId}] Attempt ${attempt} - generateLessonItems did not return 6 stages (got ${stagesCount}) or no data.`);
          if (attempt === MAX_RETRIES) {
            throw new Error(`AI returned invalid stage data for lesson "${lessonId}" after ${MAX_RETRIES} attempts (expected 6 stages).`);
          }
        }
      } catch (error) {
        console.error(`[SERVER LOG] [Lesson: ${lessonId}] Error on attempt ${attempt}/${MAX_RETRIES}:`, error instanceof Error ? error.message : String(error));
        if (attempt < MAX_RETRIES && error instanceof Error &&
          (error.message.includes('503') ||
            error.message.toLowerCase().includes('service unavailable') ||
            error.message.toLowerCase().includes('model is overloaded') ||
            error.message.toLowerCase().includes('try again later'))) {
          console.warn(`[SERVER LOG] [Lesson: ${lessonId}] API overload detected on attempt ${attempt}. Retrying in ${RETRY_DELAY_MS / 1000}s...`);
          await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS));
        } else {
          console.error(`[SERVER LOG] [Lesson: ${lessonId}] Max retries reached or non-retryable error on attempt ${attempt}. Propagating error.`);
          throw error;
        }
      }
    }

    if (!generatedLessonData || !generatedLessonData.stages || generatedLessonData.stages.length !== 6) {
      console.error(`[SERVER LOG] [Lesson: ${lessonId}] Failed to obtain 6 stages for lesson data after ${MAX_RETRIES} attempts.`)
      throw new Error(`Failed to generate lesson "${lessonId}" with 6 stages after ${MAX_RETRIES} attempts.`);
    }
    
    let totalItems = 0;
    generatedLessonData.stages.forEach(s => totalItems += (s.items?.length || 0));
    if (totalItems === 0) {
         console.error(`[SERVER LOG] [Lesson: ${lessonId}] AI returned 6 stages, but they contain no lesson items in total.`);
         throw new Error(`AI failed to return any lesson items within the 6 stages for lesson "${lessonId}".`);
    }


    if (process.env.NODE_ENV === 'development') {
      lessonCache.set(lessonId, generatedLessonData);
    }
    return generatedLessonData;

  } catch (error) {
    console.error(`[SERVER LOG] [Lesson: ${lessonId}] Overall processing failed:`, error instanceof Error ? error.message : String(error));
    if (error instanceof Error) {
      throw new Error(`Failed to process lesson "${lessonId}": ${error.message}`);
    }
    throw new Error(`Failed to process lesson "${lessonId}" due to an unknown error.`);
  }
}

/**
 * Fetches a specified number of random questions from previous lessons or stages.
 */
export async function getQuestionsForBossChallenge(
  completedLessonIds: string[],
  currentLessonId: string,
  currentStageIndex: number,
  count: number
): Promise<{ lessonId: string; item: LessonItem }[]> {
  const allQuestions: { lessonId: string; item: LessonItem }[] = [];

  const processLesson = (lesson: Lesson, lessonId: string, maxStageIndex?: number) => {
    lesson.stages.slice(0, maxStageIndex).forEach(stage => {
      stage.items.forEach(item => {
        if (item.type === 'multipleChoice' || item.type === 'freeResponse') {
          allQuestions.push({ lessonId, item });
        }
      });
    });
  };

  if (completedLessonIds.length > 0) {
    // Fetch questions from all completed lessons
    const lessons = await Promise.all(
      completedLessonIds.map(id => getGeneratedLessonById(id))
    );
    lessons.forEach((lesson, index) => {
      if (lesson) {
        processLesson(lesson, completedLessonIds[index]);
      }
    });
  } else {
    // No completed lessons (e.g., on lesson 1), fetch from previous stages of the current lesson
    if (currentStageIndex > 0) {
      const currentLesson = await getGeneratedLessonById(currentLessonId);
      if (currentLesson) {
        processLesson(currentLesson, currentLessonId, currentStageIndex);
      }
    }
  }

  // If still no questions, it's an issue (e.g., boss on stage 1 of lesson 1)
  if (allQuestions.length === 0) {
    console.warn("[getQuestionsForBossChallenge] No questions found for boss challenge. This may happen if the boss is on the first stage of the first lesson.");
    return [];
  }

  // Shuffle and pick `count` questions
  const shuffled = allQuestions.sort(() => 0.5 - Math.random());
  return shuffled.slice(0, count);
}
